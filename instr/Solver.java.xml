<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="0.9.5" language="Java" filename="code/sat4j/org.sat4j.core/src/main/java/org/sat4j/minisat/core/Solver.java"><comment type="block" format="javadoc">/*******************************************************************************
 * SAT4J: a SATisfiability library for Java Copyright (C) 2004, 2012 Artois University and CNRS
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU Lesser General Public License Version 2.1 or later (the
 * "LGPL"), in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version of
 * this file under the terms of the EPL, indicate your decision by deleting
 * the provisions above and replace them with the notice and other provisions
 * required by the LGPL. If you do not delete the provisions above, a recipient
 * may use your version of this file under the terms of the EPL or the LGPL.
 *
 * Based on the original MiniSat specification from:
 *
 * An extensible SAT solver. Niklas Een and Niklas Sorensson. Proceedings of the
 * Sixth International Conference on Theory and Applications of Satisfiability
 * Testing, LNCS 2919, pp 502-518, 2003.
 *
 * See www.minisat.se for the original solver in C++.
 *
 * Contributors:
 *   CRIL - initial API and implementation
 *******************************************************************************/</comment>
<package>package <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>minisat</name><operator>.</operator><name>core</name></name>;</package>

<import>import static <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>LiteralsUtils</name><operator>.</operator><name>toDimacs</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>LiteralsUtils</name><operator>.</operator><name>var</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintWriter</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>reflect</name><operator>.</operator><name>Field</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Comparator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Timer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>TimerTask</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>logging</name><operator>.</operator><name>Level</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>logging</name><operator>.</operator><name>Logger</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>ConstrGroup</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>LiteralsUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>Vec</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>core</name><operator>.</operator><name>VecInt</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>minisat</name><operator>.</operator><name>constraints</name><operator>.</operator><name>xor</name><operator>.</operator><name>Xor</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>Constr</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>ContradictionException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>IConstr</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>ILogAble</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>ISolver</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>ISolverService</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>IVec</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>IVecInt</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>IteratorInt</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>Lbool</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>Propagatable</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>SearchListener</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>TimeoutException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>sat4j</name><operator>.</operator><name>specs</name><operator>.</operator><name>UnitClauseProvider</name></name>;</import>

<comment type="block" format="javadoc">/**
 * The backbone of the library providing the modular implementation of a MiniSAT
 * (Chaff) like solver.
 * 
 * @author leberre
 */</comment>
<class><specifier>public</specifier> class <name><name>Solver</name><parameter_list>&lt;<parameter><name>D</name> <extends>extends <name>DataStructureFactory</name></extends></parameter>&gt;</parameter_list></name>
        <super><implements>implements <name>ISolverService</name>, <name><name>ICDCL</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></implements></super> <block>{

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>double</name></type> <name>CLAUSE_RESCALE_FACTOR</name> <init>= <expr><literal type="number">1e-20</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>double</name></type> <name>CLAUSE_RESCALE_BOUND</name> <init>= <expr><literal type="number">1</literal>
            <operator>/</operator> <name>CLAUSE_RESCALE_FACTOR</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>ILogAble</name></type> <name>out</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Set of original constraints.
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>constrs</name> <init>= <expr><operator>new</operator> <call><name><name>Vec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Set of learned constraints.
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>learnts</name> <init>= <expr><operator>new</operator> <call><name><name>Vec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Increment for clause activity.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>double</name></type> <name>claInc</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * decay factor pour l'activit? des clauses.
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>double</name></type> <name>claDecay</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * propagation queue
     */</comment>
    <comment type="line">// head of the queue in trail ... (taken from MiniSAT 1.14)</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>qhead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * variable assignments (literals) in chronological order.
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>trail</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * position of the decision levels on the trail.
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>trailLim</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * position of assumptions before starting the search.
     */</comment>
    <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>rootLevel</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>model</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>ILits</name></type> <name>voc</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>IOrder</name></type> <name>order</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ActivityComparator</name></type> <name>comparator</name> <init>= <expr><operator>new</operator> <call><name>ActivityComparator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SolverStats</name></type> <name>stats</name> <init>= <expr><operator>new</operator> <call><name>SolverStats</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>learner</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><specifier>volatile</specifier> <name>boolean</name></type> <name>undertimeout</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>long</name></type> <name>timeout</name> <init>= <expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>timeBasedTimeout</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>D</name></type> <name>dsfactory</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>SearchParams</name></type> <name>params</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>__dimacs_out</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>SearchListener</name></type> <name>slistener</name> <init>= <expr><operator>new</operator> <call><name>VoidTracing</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>RestartStrategy</name></type> <name>restarter</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name></type> <name>constrTypes</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>isDBSimplificationAllowed</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>learnedLiterals</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>boolean</name></type> <name>verbose</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>keepHot</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>String</name></type> <name>prefix</name> <init>= <expr><literal type="string">"c "</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>declaredMaxVarId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>UnitClauseProvider</name></type> <name>unitClauseProvider</name> <init>= <expr><name><name>UnitClauseProvider</name><operator>.</operator><name>VOID</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Translates an IvecInt containing Dimacs formatted variables into and
     * IVecInt containing internal formatted variables.
     * 
     * Note that for sake of efficiency, the IVecInt returned by this method is
     * always the same. DO NOT STORE IT N A CONSTRAINT.
     * 
     * @param in
     *            a vector of Dimacs formatted variables (e.g. 1,-2)
     * @return a vector of variables using internal representation (e.g 2,5)
     * @see LiteralsUtils
     * @since 2.3.6
     */</comment>
    <function><specifier>public</specifier> <type><name>IVecInt</name></type> <name>dimacs2internal</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>__dimacs_out</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>__dimacs_out</name><operator>.</operator><name>ensure</name></name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>in</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                        <argument><expr><literal type="string">"0 is not a valid variable identifier"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>__dimacs_out</name><operator>.</operator><name>unsafePush</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getFromPool</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name><name>this</name><operator>.</operator><name>__dimacs_out</name></name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * @since 2.3.1
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>registerLiteral</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getFromPool</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * creates a Solver without LearningListener. A learningListener must be
     * added to the solver, else it won't backtrack!!! A data structure factory
     * must be provided, else it won't work either.
     */</comment>

    <constructor><specifier>public</specifier> <name>Solver</name><parameter_list>(<parameter><decl><type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>learner</name></decl></parameter>, <parameter><decl><type><name>D</name></type> <name>dsf</name></decl></parameter>, <parameter><decl><type><name>IOrder</name></type> <name>order</name></decl></parameter>,
            <parameter><decl><type><name>RestartStrategy</name></type> <name>restarter</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>learner</name></expr></argument>, <argument><expr><name>dsf</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>SearchParams</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>restarter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>Solver</name><parameter_list>(<parameter><decl><type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>learner</name></decl></parameter>, <parameter><decl><type><name>D</name></type> <name>dsf</name></decl></parameter>, <parameter><decl><type><name>SearchParams</name></type> <name>params</name></decl></parameter>,
            <parameter><decl><type><name>IOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>RestartStrategy</name></type> <name>restarter</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>learner</name></expr></argument>, <argument><expr><name>dsf</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>restarter</name></expr></argument>, <argument><expr><name><name>ILogAble</name><operator>.</operator><name>CONSOLE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>Solver</name><parameter_list>(<parameter><decl><type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>learner</name></decl></parameter>, <parameter><decl><type><name>D</name></type> <name>dsf</name></decl></parameter>, <parameter><decl><type><name>SearchParams</name></type> <name>params</name></decl></parameter>,
            <parameter><decl><type><name>IOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>RestartStrategy</name></type> <name>restarter</name></decl></parameter>, <parameter><decl><type><name>ILogAble</name></type> <name>logger</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>order</name></name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>restarter</name></name> <operator>=</operator> <name>restarter</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>logger</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDataStructureFactory</name><argument_list>(<argument><expr><name>dsf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// should be called after dsf has been set up</comment>
        <expr_stmt><expr><call><name>setLearningStrategy</name><argument_list>(<argument><expr><name>learner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setDataStructureFactory(D)
     */</comment>
    <function><specifier>public</specifier> <specifier>final</specifier> <type><name>void</name></type> <name>setDataStructureFactory</name><parameter_list>(<parameter><decl><type><name>D</name></type> <name>dsf</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>dsfactory</name></name> <operator>=</operator> <name>dsf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>setUnitPropagationListener</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>setLearner</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>voc</name></name> <operator>=</operator> <call><name><name>dsf</name><operator>.</operator><name>getVocabulary</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>setLits</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>voc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isVerbose</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>verbose</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param value
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setVerbose</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>verbose</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setSearchListener(org.sat4j.specs.
     * SearchListener )
     */</comment>
    <function><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name> <extends>extends <name>ISolverService</name></extends></parameter>&gt;</parameter_list> <type><name>void</name></type> <name>setSearchListener</name><parameter_list>(
            <parameter><decl><type><name><name>SearchListener</name><argument_list type="generic">&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>sl</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>slistener</name></name> <operator>=</operator> <name>sl</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#getSearchListener()
     */</comment>
    <function><specifier>public</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name> <extends>extends <name>ISolverService</name></extends></parameter>&gt;</parameter_list> <type><name><name>SearchListener</name><argument_list type="generic">&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>getSearchListener</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>slistener</name></name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setLearner(org.sat4j.minisat.core.
     * LearningStrategy)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLearner</name><parameter_list>(<parameter><decl><type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>strategy</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setLearningStrategy</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see
     * org.sat4j.minisat.core.ICDCL#setLearningStrategy(org.sat4j.minisat.core.
     * LearningStrategy)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLearningStrategy</name><parameter_list>(<parameter><decl><type><name><name>LearningStrategy</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name></type> <name>strategy</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>learner</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learner</name><operator>.</operator><name>setSolver</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learner</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strategy</name><operator>.</operator><name>setSolver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setTimeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>t</name> <operator>*</operator> <literal type="number">1000L</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setTimeoutMs</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setTimeoutOnConflicts</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setSearchParams(org.sat4j.minisat.core.
     * SearchParams)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setSearchParams</name><parameter_list>(<parameter><decl><type><name>SearchParams</name></type> <name>sp</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>SearchParams</name></type> <name>getSearchParams</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>params</name></name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see
     * org.sat4j.minisat.core.ICDCL#setRestartStrategy(org.sat4j.minisat.core
     * .RestartStrategy)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setRestartStrategy</name><parameter_list>(<parameter><decl><type><name>RestartStrategy</name></type> <name>restarter</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>restarter</name></name> <operator>=</operator> <name>restarter</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#getRestartStrategy()
     */</comment>
    <function><specifier>public</specifier> <type><name>RestartStrategy</name></type> <name>getRestartStrategy</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>restarter</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>expireTimeout</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>timer</name><operator>.</operator><name>cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></function>

    <function><specifier>protected</specifier> <type><name>int</name></type> <name>nAssigns</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>int</name></type> <name>nConstraints</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>learn</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>learn</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>setLearnt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>register</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incLearnedclauses</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name><name>c</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incLearnedbinaryclauses</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">3</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incLearnedternaryclauses</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="line">// do nothing</comment>
        }</block></switch>
    }</block></function>

    <function><specifier>public</specifier> <specifier>final</specifier> <type><name>int</name></type> <name>decisionLevel</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <type><name>int</name></type> <name>newVar</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nVars</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>ensurePool</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>index</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>int</name></type> <name>newVar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>howmany</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>howmany</name> <operator>&gt;</operator> <name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name>
                <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nVars</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(
                    <argument><expr><literal type="string">"Caution, you are making solver's internal var id public with uncontrolled consequences with features requiring internal/hidden variables."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>ensurePool</name></name><argument_list>(<argument><expr><name>howmany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name> <operator>=</operator> <name>howmany</name></expr>;</expr_stmt>
        <return>return <expr><name>howmany</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addClause</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>vlits</name> <init>= <expr><call><name>dimacs2internal</name><argument_list>(<argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>addConstr</name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createClause</name></name><argument_list>(<argument><expr><name>vlits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>removeConstr</name><parameter_list>(<parameter><decl><type><name>IConstr</name></type> <name>co</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>co</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><literal type="string">"Reference to the constraint to remove needed!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>Constr</name><operator>)</operator> <name>co</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>removeFromLast</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clearLearntClauses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>type</name> <init>= <expr><call><name><name>c</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>dec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>removeSubsumedConstr</name><parameter_list>(<parameter><decl><type><name>IConstr</name></type> <name>co</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>co</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><literal type="string">"Reference to the constraint to remove needed!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>co</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><literal type="string">"Can only remove latest added constraint!!!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>Constr</name><operator>)</operator> <name>co</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>type</name> <init>= <expr><call><name><name>c</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>dec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>addAllClauses</name><parameter_list>(<parameter><decl><type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>IVecInt</name></argument>&gt;</argument_list></name></type> <name>clauses</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>IVecInt</name></argument>&gt;</argument_list></name></type> <name>iterator</name> <init>= <expr><call><name><name>clauses</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name>
                <operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <expr_stmt><expr><call><name>addClause</name><argument_list>(<argument><expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addAtMost</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>degree</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>literals</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>opliterals</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>IteratorInt</name></type> <name>iterator</name> <init>= <expr><call><name><name>literals</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <expr_stmt><expr><call><name><name>opliterals</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><operator>-</operator><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name>addAtLeast</name><argument_list>(<argument><expr><name>opliterals</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <name>degree</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addAtLeast</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>degree</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>vlits</name> <init>= <expr><call><name>dimacs2internal</name><argument_list>(<argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>addConstr</name><argument_list>(
                <argument><expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createCardinalityConstraint</name></name><argument_list>(<argument><expr><name>vlits</name></expr></argument>, <argument><expr><name>degree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addExactly</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>ConstrGroup</name></type> <name>group</name> <init>= <expr><operator>new</operator> <call><name>ConstrGroup</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>group</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>addAtMost</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>group</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>addAtLeast</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>group</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addParity</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>even</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>vlits</name> <init>= <expr><call><name>dimacs2internal</name><argument_list>(<argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>addConstr</name><argument_list>(<argument><expr><call><name><name>Xor</name><operator>.</operator><name>createParityConstraint</name></name><argument_list>(<argument><expr><name>vlits</name></expr></argument>, <argument><expr><name>even</name></expr></argument>, <argument><expr><name>voc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation>
    <specifier>public</specifier> <type><name>boolean</name></type> <name>simplifyDB</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// Simplifie la base de clauses apres la premiere propagation des</comment>
        <comment type="line">// clauses unitaires</comment>
        <decl_stmt><decl><type><name><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name><index>[]</index></name></type> <name>cs</name> <init>= <expr><operator>new</operator> <name><name>IVec</name><index>[]</index></name> <block>{ <expr><name><name>this</name><operator>.</operator><name>constrs</name></name></expr>, <expr><name><name>this</name><operator>.</operator><name>learnts</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>type</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>type</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cs</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><name><name>cs</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>simplify</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// enleve les contraintes satisfaites de la base</comment>
                    <expr_stmt><expr><name><name>cs</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>remove</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>cs</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>moveTo</name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
            <expr_stmt><expr><name><name>cs</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>shrinkTo</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Si un mod?le est trouv?, ce vecteur contient le mod?le.
     * 
     * @return un mod?le de la formule.
     */</comment>
    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>model</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>model</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(
                    <argument><expr><literal type="string">"Call the solve method first!!!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>nmodel</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>this</name><operator>.</operator><name>model</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nmodel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>model</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>nmodel</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#enqueue(int)
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>enqueue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>enqueue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#enqueue(int,
     * org.sat4j.minisat.core.Constr)
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>enqueue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>Constr</name></type> <name>from</name></decl></parameter>)</parameter_list> <block>{
        <assert>assert <expr><name>p</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</assert>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// literal is already satisfied. Skipping.</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isFalsified</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// conflicting enqueued assignment</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>enqueueing</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// new fact, store it</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>satisfies</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>setLevel</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>decisionLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>setReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>from</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>from</name><operator>.</operator><name>learnt</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>onPropagation</name></name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>mseen</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>mpreason</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>moutLearnt</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @throws TimeoutException
     *             if the timeout is reached during conflict analysis.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>analyze</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>confl</name></decl></parameter>, <parameter><decl><type><name>Pair</name></type> <name>results</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <assert>assert <expr><name>confl</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>seen</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mseen</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>outLearnt</name> <init>= <expr><name><name>this</name><operator>.</operator><name>moutLearnt</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>preason</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mpreason</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <assert>assert <expr><call><name><name>outLearnt</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</assert>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seen</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><name>int</name></type> <name>counter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// placeholder for the asserting literal</comment>
        <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>outBtlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IConstr</name></type> <name>prevConfl</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <do>do <block>{
            <expr_stmt><expr><call><name><name>preason</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><name>confl</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <if>if <condition>(<expr><name>prevConfl</name> <operator>!=</operator> <name>confl</name> <operator>||</operator> <call><name><name>confl</name><operator>.</operator><name>canBePropagatedMultipleTimes</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>confl</name><operator>.</operator><name>calcReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>preason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name>
                        <operator>.</operator><name>onConflictAnalysis</name></name><argument_list>(<argument><expr><name>confl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Trace reason for p</comment>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>preason</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><call><name><name>preason</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>updateVar</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>seen</name><index>[<expr><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>counter</name><operator>++</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>updateVarAtDecisionLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <elseif>else <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                            <comment type="line">// only literals assigned after decision level 0</comment>
                            <comment type="line">// part of</comment>
                            <comment type="line">// the explanation</comment>
                            <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>q</name> <operator>^</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>outBtlevel</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>outBtlevel</name></expr></argument>,
                                    <argument><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if></elseif></if>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
            <expr_stmt><expr><name>prevConfl</name> <operator>=</operator> <name>confl</name></expr>;</expr_stmt>
            <comment type="line">// select next reason to look at</comment>
            <do>do <block>{
                <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name>p</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>;</do>
            <comment type="line">// seen[p.var] indique que p se trouve dans outLearnt ou dans</comment>
            <comment type="line">// le dernier niveau de d?cision</comment>
        }</block> while <condition>(<expr><operator>--</operator><name>counter</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

        <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name> <operator>^</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>simplifier</name><operator>.</operator><name>simplify</name></name><argument_list>(<argument><expr><name>outLearnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createUnregisteredClause</name></name><argument_list>(<argument><expr><name>outLearnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>onClauseLearning</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>setReason</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <assert>assert <expr><name>outBtlevel</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>;</assert>
        <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>setBacktrackLevel</name></name><argument_list>(<argument><expr><name>outBtlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Derive a subset of the assumptions causing the inconsistency.
     * 
     * @param confl
     *            the last conflict of the search, occuring at root level.
     * @param assumps
     *            the set of assumption literals
     * @param conflictingLiteral
     *            the literal detected conflicting while propagating
     *            assumptions.
     * @return a subset of assumps causing the inconsistency.
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>IVecInt</name></type> <name>analyzeFinalConflictInTermsOfAssumptions</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>confl</name></decl></parameter>,
            <parameter><decl><type><name>IVecInt</name></type> <name>assumps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conflictingLiteral</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>assumps</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <while>while <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <comment type="line">// conflict detected when assuming a value</comment>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>seen</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mseen</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>outLearnt</name> <init>= <expr><name><name>this</name><operator>.</operator><name>moutLearnt</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>preason</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mpreason</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <comment type="line">// conflict detected on unit clauses</comment>
            <return>return <expr><name>outLearnt</name></expr>;</return>
        }</block></then></if>

        <assert>assert <expr><call><name><name>outLearnt</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</assert>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seen</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>seen</name><index>[<expr><name>conflictingLiteral</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
                <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>==</operator> <operator>(</operator><name>conflictingLiteral</name> <operator>^</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
        <if>if <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>outLearnt</name></expr>;</return>
        }</block></then></if>
        <do>do <block>{

            <expr_stmt><expr><call><name><name>preason</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>confl</name><operator>.</operator><name>calcReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>preason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Trace reason for p</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>preason</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><call><name><name>preason</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>seen</name><index>[<expr><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal>
                            <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <assert>assert <expr><call><name><name>assumps</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
                        <expr_stmt><expr><call><name><name>outLearnt</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>

            <comment type="line">// select next reason to look at</comment>
            <do>do <block>{
                <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
                        <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block> while <condition>(<expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
                    <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>seen</name><index>[<expr><name>p</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name>confl</name> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr>)</condition>;</do>
        }</block> while <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
        <return>return <expr><name>outLearnt</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>ISimplifier</name></type> <name>NO_SIMPLIFICATION</name> <init>= <expr><operator>new</operator> <class><super><name>ISimplifier</name></super><argument_list>()</argument_list> <block>{
        <comment type="block" format="javadoc">/**
         * 
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <function><specifier>public</specifier> <type><name>void</name></type> <name>simplify</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>outLearnt</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><literal type="string">"No reason simplification"</literal></expr>;</return> <comment type="line">//$NON-NLS-1$</comment>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>ISimplifier</name></type> <name>SIMPLE_SIMPLIFICATION</name> <init>= <expr><operator>new</operator> <class><super><name>ISimplifier</name></super><argument_list>()</argument_list> <block>{
        <comment type="block" format="javadoc">/**
         * 
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <function><specifier>public</specifier> <type><name>void</name></type> <name>simplify</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>simpleSimplification</name><argument_list>(<argument><expr><name>conflictToReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><literal type="string">"Simple reason simplification"</literal></expr>;</return> <comment type="line">//$NON-NLS-1$</comment>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>ISimplifier</name></type> <name>EXPENSIVE_SIMPLIFICATION</name> <init>= <expr><operator>new</operator> <class><super><name>ISimplifier</name></super><argument_list>()</argument_list> <block>{

        <comment type="block" format="javadoc">/**
         * 
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <function><specifier>public</specifier> <type><name>void</name></type> <name>simplify</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>expensiveSimplification</name><argument_list>(<argument><expr><name>conflictToReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><literal type="string">"Expensive reason simplification"</literal></expr>;</return> <comment type="line">//$NON-NLS-1$</comment>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>ISimplifier</name></type> <name>EXPENSIVE_SIMPLIFICATION_WLONLY</name> <init>= <expr><operator>new</operator> <class><super><name>ISimplifier</name></super><argument_list>()</argument_list> <block>{

        <comment type="block" format="javadoc">/**
         * 
         */</comment>
        <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

        <function><specifier>public</specifier> <type><name>void</name></type> <name>simplify</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>expensiveSimplificationWLOnly</name><argument_list>(<argument><expr><name>conflictToReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><literal type="string">"Expensive reason simplification specific for WL data structure"</literal></expr>;</return> <comment type="line">//$NON-NLS-1$</comment>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>ISimplifier</name></type> <name>simplifier</name> <init>= <expr><name>NO_SIMPLIFICATION</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setSimplifier(java.lang.String)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setSimplifier</name><parameter_list>(<parameter><decl><type><name>SimplificationType</name></type> <name>simp</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Field</name></type> <name>f</name></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>Solver</name><operator>.</operator><name><name>class</name><operator>.</operator><name>getDeclaredField</name></name></name><argument_list>(<argument><expr><call><name><name>simp</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>simplifier</name></name> <operator>=</operator> <operator>(</operator><name>ISimplifier</name><operator>)</operator> <call><name><name>f</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>Logger</name><operator>.</operator><name>getLogger</name></name><argument_list>(<argument><expr><literal type="string">"org.sat4j.core"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>log</name><argument_list>(<argument><expr><name><name>Level</name><operator>.</operator><name>INFO</name></name></expr></argument>,
                    <argument><expr><literal type="string">"Issue when assigning simplifier: disabling simplification"</literal></expr></argument>,
                    <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>simplifier</name></name> <operator>=</operator> <name>NO_SIMPLIFICATION</name></expr>;</expr_stmt>
        }</block></catch></try>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see
     * org.sat4j.minisat.core.ICDCL#setSimplifier(org.sat4j.minisat.core.Solver
     * .ISimplifier)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setSimplifier</name><parameter_list>(<parameter><decl><type><name>ISimplifier</name></type> <name>simp</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>simplifier</name></name> <operator>=</operator> <name>simp</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#getSimplifier()
     */</comment>
    <function><specifier>public</specifier> <type><name>ISimplifier</name></type> <name>getSimplifier</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>simplifier</name></name></expr>;</return>
    }</block></function>

    <comment type="line">// MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson</comment>
    <comment type="line">//</comment>
    <comment type="line">// Permission is hereby granted, free of charge, to any person obtaining a</comment>
    <comment type="line">// copy of this software and associated documentation files (the</comment>
    <comment type="line">// "Software"), to deal in the Software without restriction, including</comment>
    <comment type="line">// without limitation the rights to use, copy, modify, merge, publish,</comment>
    <comment type="line">// distribute, sublicense, and/or sell copies of the Software, and to</comment>
    <comment type="line">// permit persons to whom the Software is furnished to do so, subject to</comment>
    <comment type="line">// the following conditions:</comment>
    <comment type="line">//</comment>
    <comment type="line">// The above copyright notice and this permission notice shall be included</comment>
    <comment type="line">// in all copies or substantial portions of the Software.</comment>
    <comment type="line">//</comment>
    <comment type="line">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</comment>
    <comment type="line">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</comment>
    <comment type="line">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</comment>
    <comment type="line">// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</comment>
    <comment type="line">// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</comment>
    <comment type="line">// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</comment>
    <comment type="line">// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</comment>

    <comment type="line">// Taken from MiniSAT 1.14: Simplify conflict clause (a little):</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>simpleSimplification</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>seen</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mseen</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IConstr</name></type> <name>r</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>conflictToReduce</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>r</name><operator>.</operator><name>canBePropagatedMultipleTimes</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>moveTo</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <call><name><name>r</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>r</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name>p</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isFalsified</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
                            <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>moveTo</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
            }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incReducedliterals</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>analyzetoclear</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>IVecInt</name></type> <name>analyzestack</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Taken from MiniSAT 1.14</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>expensiveSimplification</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Simplify conflict clause (a lot):</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <comment type="line">// (maintain an abstraction of levels involved in conflict)</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>copyTo</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>analyzetoclear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>conflictToReduce</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal>
                    <operator>||</operator> <operator>!</operator><call><name>analyzeRemovable</name><argument_list>(<argument><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>moveTo</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incReducedliterals</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Check if 'p' can be removed.' min_level' is used to abort early if</comment>
    <comment type="line">// visiting literals at a level that cannot be removed.</comment>
    <comment type="line">//</comment>
    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>analyzeRemovable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <decl_stmt><decl><type><name>ILits</name></type> <name>lvoc</name> <init>= <expr><name><name>this</name><operator>.</operator><name>voc</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>lanalyzestack</name> <init>= <expr><name><name>this</name><operator>.</operator><name>analyzestack</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>lanalyzetoclear</name> <init>= <expr><name><name>this</name><operator>.</operator><name>analyzetoclear</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lanalyzestack</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lanalyzestack</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>seen</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mseen</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>lanalyzestack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><call><name><name>lanalyzestack</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>lvoc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><call><name><name>lvoc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>lanalyzestack</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>c</name><operator>.</operator><name>canBePropagatedMultipleTimes</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>top</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>lanalyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><name><name>seen</name><index>[<expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>c</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name><name>c</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><call><name>var</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name><name>lvoc</name><operator>.</operator><name>isFalsified</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call>
                        <operator>&amp;&amp;</operator> <call><name><name>lvoc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name><name>lvoc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>top</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>lanalyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                            <expr_stmt><expr><name><name>seen</name><index>[<expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>seen</name><index>[<expr><name>l</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>lanalyzestack</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>lanalyzetoclear</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

        }</block></while>

        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">// Taken from MiniSAT 1.14</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>expensiveSimplificationWLOnly</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>conflictToReduce</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Simplify conflict clause (a lot):</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <comment type="line">// (maintain an abstraction of levels involved in conflict)</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>copyTo</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>analyzetoclear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>conflictToReduce</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal>
                    <operator>||</operator> <operator>!</operator><call><name>analyzeRemovableWLOnly</name><argument_list>(<argument><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>moveTo</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>conflictToReduce</name><operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incReducedliterals</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Check if 'p' can be removed.' min_level' is used to abort early if</comment>
    <comment type="line">// visiting literals at a level that cannot be removed.</comment>
    <comment type="line">//</comment>
    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>analyzeRemovableWLOnly</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>boolean</name><index>[]</index></name></type> <name>seen</name> <init>= <expr><name><name>this</name><operator>.</operator><name>mseen</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>c</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name><name>c</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><call><name>var</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>top</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                            <expr_stmt><expr><name><name>seen</name><index>[<expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name>
                                <operator>.</operator><name>shrink</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>seen</name><index>[<expr><name>l</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzestack</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analyzetoclear</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></while>

        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <comment type="line">// END Minisat 1.14 cut and paste</comment>

    <comment type="block" format="javadoc">/**
     * 
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>undoOne</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// gather last assigned literal</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>p</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</assert>
        <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</assert>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>p</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// unassign variable</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>unassign</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>setReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>setLevel</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update heuristics value</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>undo</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// remove literal from the trail</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update constraints on backtrack.</comment>
        <comment type="line">// not used if the solver uses watched literals.</comment>
        <decl_stmt><decl><type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Undoable</name></argument>&gt;</argument_list></name></type> <name>undos</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>undos</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>undos</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>undos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>size</name><operator>--</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name><name>undos</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>undo</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>undos</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Propagate activity to a constraint
     * 
     * @param confl
     *            a constraint
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>claBumpActivity</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>confl</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>confl</name><operator>.</operator><name>incActivity</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>claInc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>confl</name><operator>.</operator><name>getActivity</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>CLAUSE_RESCALE_BOUND</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>claRescalActivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// for (int i = 0; i &lt; confl.size(); i++) {</comment>
            <comment type="line">// varBumpActivity(confl.get(i));</comment>
            <comment type="line">// }</comment>
        }</block></then></if>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>varBumpActivity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>updateVar</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>claRescalActivity</name><parameter_list>()</parameter_list> <block>{
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>rescaleBy</name><argument_list>(<argument><expr><name>CLAUSE_RESCALE_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>claInc</name></name> <operator>*=</operator> <name>CLAUSE_RESCALE_FACTOR</name></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Propagatable</name></argument>&gt;</argument_list></name></type> <name>watched</name> <init>= <expr><operator>new</operator> <call><name><name>Vec</name><argument_list type="generic">&lt;<argument><name>Propagatable</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @return null if not conflict is found, else a conflicting constraint.
     */</comment>
    <function><specifier>public</specifier> <specifier>final</specifier> <type><name>Constr</name></type> <name>propagate</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>ltrail</name> <init>= <expr><name><name>this</name><operator>.</operator><name>trail</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SolverStats</name></type> <name>lstats</name> <init>= <expr><name><name>this</name><operator>.</operator><name>stats</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IOrder</name></type> <name>lorder</name> <init>= <expr><name><name>this</name><operator>.</operator><name>order</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SearchListener</name></type> <name>lslistener</name> <init>= <expr><name><name>this</name><operator>.</operator><name>slistener</name></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// ltrail.size() changes due to propagation</comment>
        <comment type="line">// cannot cache that value.</comment>
        <while>while <condition>(<expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>&lt;</operator> <call><name><name>ltrail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>lstats</name><operator>.</operator><name>incPropagations</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>ltrail</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>qhead</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>lslistener</name><operator>.</operator><name>propagating</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lorder</name><operator>.</operator><name>assignLiteral</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Constr</name></type> <name>confl</name> <init>= <expr><call><name>reduceClausesContainingTheNegationOf</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>confl</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>confl</name></expr>;</return>
            }</block></then></if>
        }</block></while>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>Constr</name></type> <name>reduceClausesContainingTheNegationOf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// p is the literal to propagate</comment>
        <comment type="line">// Moved original MiniSAT code to dsfactory to avoid</comment>
        <comment type="line">// watches manipulation in counter Based clauses for instance.</comment>
        <assert>assert <expr><name>p</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</assert>
        <decl_stmt><decl><type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Propagatable</name></argument>&gt;</argument_list></name></type> <name>lwatched</name> <init>= <expr><name><name>this</name><operator>.</operator><name>watched</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lwatched</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>watches</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>moveTo</name><argument_list>(<argument><expr><name>lwatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> <init>= <expr><call><name><name>lwatched</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incInspects</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// try shortcut</comment>
            <comment type="line">// shortcut = shortcuts.get(i);</comment>
            <comment type="line">// if (shortcut != ILits.UNDEFINED &amp;&amp; voc.isSatisfied(shortcut))</comment>
            <comment type="line">// {</comment>
            <comment type="line">// voc.watch(p, watched.get(i), shortcut);</comment>
            <comment type="line">// stats.shortcuts++;</comment>
            <comment type="line">// continue;</comment>
            <comment type="line">// }</comment>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>lwatched</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>propagate</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// Constraint is conflicting: copy remaining watches to</comment>
                <comment type="line">// watches[p]</comment>
                <comment type="line">// and return constraint</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sizew</name> <init>= <expr><call><name><name>lwatched</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>sizew</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>watch</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name><name>lwatched</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// propQ.clear();</comment>
                <return>return <expr><call><name><name>lwatched</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toConstraint</name><argument_list>()</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name>record</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>constr</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>constr</name><operator>.</operator><name>assertConstraint</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name>toDimacs</name><argument_list>(<argument><expr><call><name><name>constr</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>adding</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>constr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incLearnedliterals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>learnUnit</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learner</name><operator>.</operator><name>learns</name></name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return false ssi conflit imm?diat.
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>assume</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// Precondition: assume propagation queue is empty</comment>
        <comment type="line">// assert this.trail.size() == this.qhead; no longer true with computing</comment>
        <comment type="line">// PI</comment>
        <assert>assert <expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>enqueue</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Revert to the state before the last assume()
     */</comment>
    <function><type><name>void</name></type> <name>cancel</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// assert trail.size() == qhead || !undertimeout;</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>decisionvar</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>unsafeGet</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>backtracking</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>decisionvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>c</name><operator>--</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Restore literals
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>cancelLearntLiterals</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>learnedLiteralsLimit</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedLiterals</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// assert trail.size() == qhead || !undertimeout;</comment>
        <while>while <condition>(<expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>learnedLiteralsLimit</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedLiterals</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <comment type="line">// qhead = 0;</comment>
        <comment type="line">// learnedLiterals = 0;</comment>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Cancel several levels of assumptions
     * 
     * @param level
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>cancelUntil</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{
        <while>while <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>level</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><specifier>protected</specifier> <type><name>void</name></type> <name>cancelUntilTrailLevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{
        <while>while <condition>(<expr><operator>!</operator><call><name><name>trail</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>level</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>trailLim</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>decisions</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>Pair</name></type> <name>analysisResult</name> <init>= <expr><operator>new</operator> <call><name>Pair</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>boolean</name><index>[]</index></name></type> <name>userbooleanmodel</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>IVecInt</name></type> <name>unsatExplanationInTermsOfAssumptions</name></decl>;</decl_stmt>

    <function><specifier>private</specifier> <type><name>Lbool</name></type> <name>search</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>assumps</name></decl></parameter>)</parameter_list> <block>{
        <assert>assert <expr><name><name>this</name><operator>.</operator><name>rootLevel</name></name> <operator>==</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incStarts</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>backjumpLevel</name></decl>;</decl_stmt>

        <comment type="line">// varDecay = 1 / params.varDecay;</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>setVarDecay</name></name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>/</operator> <call><name><name>this</name><operator>.</operator><name>params</name><operator>.</operator><name>getVarDecay</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>claDecay</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>/</operator> <call><name><name>this</name><operator>.</operator><name>params</name><operator>.</operator><name>getClaDecay</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <do>do <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>beginLoop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// propagate unit clauses and other constraints</comment>
            <decl_stmt><decl><type><name>Constr</name></type> <name>confl</name> <init>= <expr><call><name>propagate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>this</name><operator>.</operator><name>qhead</name></name></expr>;</assert>

            <if>if <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <comment type="line">// No conflict found</comment>
                <if>if <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>isDBSimplificationAllowed</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incRootSimplifications</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>ret</name> <init>= <expr><call><name>simplifyDB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <assert>assert <expr><name>ret</name></expr>;</assert>
                }</block></then></if>
                <assert>assert <expr><call><name>nAssigns</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>realnVars</name></name><argument_list>()</argument_list></call></expr>;</assert>
                <if>if <condition>(<expr><call><name>nAssigns</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>realnVars</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>modelFound</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>solutionFound</name></name><argument_list>(
                            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name></expr>
                                    </then><else>: <expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></else></ternary></expr></argument>,
                            <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name><name>Lbool</name><operator>.</operator><name>TRUE</name></name></expr>;</return>
                    }</block></then> <else>else <block>{
                        <comment type="line">// this.sharedConflict;</comment>
                        <if>if <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>==</operator> <name>rootLevel</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>confl</name> <operator>=</operator> <name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>sharedConflict</name>
                                    <operator>.</operator><name>getAssertionLevel</name></name><argument_list>(<argument><expr><name>trail</name></expr></argument>, <argument><expr><call><name>decisionLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>cancelUntilTrailLevel</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>sharedConflict</name><operator>.</operator><name>assertConstraint</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>

                            <continue>continue;</continue>
                        }</block></else></if>
                    }</block></else></if>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>restarter</name><operator>.</operator><name>shouldRestart</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>;</return>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>needToReduceDB</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>reduceDB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>needToReduceDB</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                        <comment type="line">// New variable decision</comment>
                        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incDecisions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>select</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr>)</condition><then> <block>{
                            <comment type="line">// check (expensive) if all the constraints are not</comment>
                            <comment type="line">// satisfied</comment>
                            <decl_stmt><decl><type><name>boolean</name></type> <name>allsat</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                                <if>if <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isSatisfied</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                                    <expr_stmt><expr><name>allsat</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                }</block></then></if>
                            }</block></for>
                            <if>if <condition>(<expr><name>allsat</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>modelFound</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name>
                                        <operator>.</operator><name>solutionFound</name></name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator></expr>
                                                ?</condition><then> <expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name></expr>
                                                </then><else>: <expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><name><name>Lbool</name><operator>.</operator><name>TRUE</name></name></expr>;</return>
                            }</block></then> <else>else <block>{
                                <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name>preventTheSameDecisionsToBeMade</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>lastConflictMeansUnsat</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></then> <else>else <block>{
                            <assert>assert <expr><name>p</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</assert>
                            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>assuming</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>boolean</name></type> <name>ret</name> <init>= <expr><call><name>assume</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <assert>assert <expr><name>ret</name></expr>;</assert>
                        }</block></else></if>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>confl</name> <operator>=</operator> <name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><name>confl</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <comment type="line">// conflict found</comment>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incConflicts</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>conflictFound</name></name><argument_list>(<argument><expr><name>confl</name></expr></argument>, <argument><expr><call><name>decisionLevel</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name><operator>.</operator><name>newConflict</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>lastConflictMeansUnsat</name></name></expr>)</condition><then> <block>{
                        <comment type="line">// conflict at root level, the formula is inconsistent</comment>
                        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name></name> <operator>=</operator> <call><name>analyzeFinalConflictInTermsOfAssumptions</name><argument_list>(
                                <argument><expr><name>confl</name></expr></argument>, <argument><expr><name>assumps</name></expr></argument>, <argument><expr><name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name><name>Lbool</name><operator>.</operator><name>FALSE</name></name></expr>;</return>
                    }</block></then></if>
                    <return>return <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>;</return>
                }</block></then></if>
                <decl_stmt><decl><type><name>int</name></type> <name>conflictTrailLevel</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// analyze conflict</comment>
                <try>try <block>{
                    <expr_stmt><expr><call><name>analyze</name><argument_list>(<argument><expr><name>confl</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>analysisResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch <parameter_list>(<parameter><decl><type><name>TimeoutException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
                    <return>return <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>;</return>
                }</block></catch></try>
                <assert>assert <expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name>
                        <operator>.</operator><name>getBacktrackLevel</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call></expr>;</assert>
                <expr_stmt><expr><name>backjumpLevel</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(
                        <argument><expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name><operator>.</operator><name>getBacktrackLevel</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>backjump</name></name><argument_list>(<argument><expr><name>backjumpLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><name>backjumpLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>backjumpLevel</name> <operator>==</operator> <name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>restarter</name><operator>.</operator><name>onBackjumpToRootLevel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <assert>assert <expr><call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name><name>this</name><operator>.</operator><name>rootLevel</name></name>
                        <operator>&amp;&amp;</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>this</name><operator>.</operator><name>analysisResult</name>
                                <operator>.</operator><name>getBacktrackLevel</name></name><argument_list>()</argument_list></call></expr>;</assert>
                <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name><operator>.</operator><name>getReason</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><name><name>Lbool</name><operator>.</operator><name>FALSE</name></name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><call><name>record</name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name><operator>.</operator><name>getReason</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>restarter</name><operator>.</operator><name>newLearnedClause</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name><operator>.</operator><name>getReason</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>conflictTrailLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>analysisResult</name><operator>.</operator><name>setReason</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>decayActivities</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name></expr>)</condition>;</do>
        <return>return <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>;</return> <comment type="line">// timeout occured</comment>
    }</block></function>

    <function><specifier>private</specifier> <type><name>Constr</name></type> <name>preventTheSameDecisionsToBeMade</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>clause</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><call><name>nVars</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name><name>this</name><operator>.</operator><name>rootLevel</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>p</name> <operator>^</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createUnregisteredClause</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>protected</specifier> <type><name>void</name></type> <name>analyzeAtRootLevel</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>conflict</name></decl></parameter>)</parameter_list> <block>{
    }</block></function>

    <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>implied</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>IVecInt</name></type> <name>decisions</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>fullmodel</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * 
     */</comment>
    <function><type><name>void</name></type> <name>modelFound</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>decisions</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>tempmodel</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><call><name>nVars</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name></name> <operator>=</operator> <operator>new</operator> <name><name>boolean</name><index>[<expr><call><name>realNumberOfVariables</name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Constr</name></type> <name>reason</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>nVars</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>belongsToPool</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getFromPool</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isUnassigned</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>tempmodel</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><operator>-</operator><name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>reason</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
                            <comment type="line">// we consider literals propagated by learned</comment>
                            <comment type="line">// clauses</comment>
                            <comment type="line">// as decisions to allow blocking models by</comment>
                            <comment type="line">// decisions.</comment>
                            <operator>||</operator> <name>reason</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>reason</name><operator>.</operator><name>learnt</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>decisions</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>tempmodel</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>implied</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>tempmodel</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>model</name></name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>tempmodel</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tempmodel</name><operator>.</operator><name>copyTo</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>realNumberOfVariables</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name>nVars</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>nVars</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>realNumberOfVariables</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>belongsToPool</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getFromPool</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isUnassigned</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>tempmodel</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><operator>-</operator><name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getReason</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>decisions</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>tempmodel</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>implied</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>tempmodel</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>tempmodel</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tempmodel</name><operator>.</operator><name>moveTo</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>=</operator> <name><name>this</name><operator>.</operator><name>model</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Forget a variable in the formula by falsifying both its positive and
     * negative literals.
     * 
     * @param var
     *            a variable
     * @return a conflicting constraint resulting from the disparition of those
     *         literals.
     */</comment>
    <function><type><name>Constr</name></type> <name>forget</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>var</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>satisfied</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><call><name>toInternal</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>forgets</name></name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Constr</name></type> <name>confl</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>satisfied</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name>reduceClausesContainingTheNegationOf</name><argument_list>(
                    <argument><expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><operator>-</operator><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>confl</name> <operator>=</operator> <call><name>reduceClausesContainingTheNegationOf</name><argument_list>(
                    <argument><expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>confl</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><specifier>protected</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>prime</name></decl>;</decl_stmt>

    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>primeImplicant</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>primeApproach</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><literal type="string">"prime"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PrimeImplicantStrategy</name></type> <name>strategy</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><literal type="string">"OLD"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>primeApproach</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <operator>new</operator> <call><name>QuadraticPrimeImplicantStrategy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><literal type="string">"ALGO2"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>primeApproach</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <operator>new</operator> <call><name>CounterBasedPrimeImplicantStrategy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <operator>new</operator> <call><name>WatcherBasedPrimeImplicantStrategy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>implicant</name> <init>= <expr><call><name><name>strategy</name><operator>.</operator><name>compute</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>prime</name></name> <operator>=</operator> <call><name><name>strategy</name><operator>.</operator><name>getPrimeImplicantAsArrayWithHoles</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>implicant</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>primeImplicant</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>p</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>realNumberOfVariables</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><literal type="string">"Use a valid Dimacs var id as argument!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>prime</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(
                    <argument><expr><literal type="string">"Call the primeImplicant method first!!!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <return>return <expr><name><name>this</name><operator>.</operator><name>prime</name><index>[<expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name>p</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>model</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>var</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>var</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>var</name> <operator>&gt;</operator> <call><name>realNumberOfVariables</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><literal type="string">"Use a valid Dimacs var id as argument!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(
                    <argument><expr><literal type="string">"Call the solve method first!!!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <return>return <expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name><index>[<expr><name>var</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>clearLearntClauses</name><parameter_list>()</parameter_list> <block>{
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>iterator</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name>
                <operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <expr_stmt><expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>remove</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedLiterals</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>protected</specifier> <specifier>final</specifier> <type><name>void</name></type> <name>reduceDB</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incReduceddb</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>cleaning</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>reduce</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>learnts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>protected</specifier> <type><name>void</name></type> <name>sortOnActivity</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>comparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * 
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>decayActivities</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>varDecayActivity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>claDecayActivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * 
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>claDecayActivity</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>claInc</name></name> <operator>*=</operator> <name><name>this</name><operator>.</operator><name>claDecay</name></name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return true iff the set of constraints is satisfiable, else false.
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isSatisfiable</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>isSatisfiable</name><argument_list>(<argument><expr><name><name>VecInt</name><operator>.</operator><name>EMPTY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return true iff the set of constraints is satisfiable, else false.
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isSatisfiable</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>global</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>isSatisfiable</name><argument_list>(<argument><expr><name><name>VecInt</name><operator>.</operator><name>EMPTY</name></name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><name>double</name></type> <name>timebegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>needToReduceDB</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>ConflictTimerContainer</name></type> <name>conflictCount</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <specifier>transient</specifier> <type><name>Timer</name></type> <name>timer</name></decl>;</decl_stmt>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isSatisfiable</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>assumps</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>isSatisfiable</name><argument_list>(<argument><expr><name>assumps</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <specifier>final</specifier> <type><name>LearnedConstraintsDeletionStrategy</name></type> <name>fixedSize</name><parameter_list>(
            <parameter><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxsize</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <class><super><name>LearnedConstraintsDeletionStrategy</name></super><argument_list>()</argument_list> <block>{

            <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ConflictTimer</name></type> <name>aTimer</name> <init>= <expr><operator>new</operator> <class><super><name>ConflictTimerAdapter</name></super><argument_list>(
                    <argument><expr><name><name>Solver</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>)</argument_list> <block>{

                <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

                <function><annotation>@<name>Override</name></annotation>
                <specifier>public</specifier> <type><name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
                    <expr_stmt><expr><call><name>getSolver</name><argument_list>()</argument_list></call><operator>.</operator><call><name>setNeedToReduceDB</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>

            <function><specifier>public</specifier> <type><name>void</name></type> <name>reduce</name><parameter_list>(<parameter><decl><type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>learnedConstrs</name></decl></parameter>)</parameter_list> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><operator>(</operator><operator>)</operator>
                        <operator>&amp;&amp;</operator> <name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><operator>(</operator><operator>)</operator> <operator>-</operator> <name>k</name></argument> &gt;</argument_list></name> <name>maxsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <decl_stmt><decl><type><name>Constr</name></type> <name>c</name> <init>= <expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>c</name><operator>.</operator><name>locked</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>c</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>,
                                <argument><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name><name>Solver</name><operator>.</operator><name>this</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></for>
                <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <if>if <condition>(<expr><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>verbose</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>out</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><call><name>getLogPrefix</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"cleaning "</literal> <comment type="line">//$NON-NLS-1$</comment>
                            <operator>+</operator> <operator>(</operator><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>j</name><operator>)</operator>
                            <operator>+</operator> <literal type="string">" clauses out of "</literal> <operator>+</operator> <call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
                    <comment type="line">// out.flush();</comment>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>shrinkTo</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>

            <function><specifier>public</specifier> <type><name>void</name></type> <name>onConflictAnalysis</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{
                <comment type="line">// TODO Auto-generated method stub</comment>

            }</block></function>

            <function><specifier>public</specifier> <type><name>void</name></type> <name>onClauseLearning</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>outLearnt</name></decl></parameter>)</parameter_list> <block>{
                <comment type="line">// TODO Auto-generated method stub</comment>

            }</block></function>

            <function><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr><literal type="string">"Fixed size ("</literal> <operator>+</operator> <name>maxsize</name>
                        <operator>+</operator> <literal type="string">") learned constraints deletion strategy"</literal></expr>;</return>
            }</block></function>

            <function><specifier>public</specifier> <type><name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{
            }</block></function>

            <function><specifier>public</specifier> <type><name>ConflictTimer</name></type> <name>getTimer</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr><name><name>this</name><operator>.</operator><name>aTimer</name></name></expr>;</return>
            }</block></function>

            <function><specifier>public</specifier> <type><name>void</name></type> <name>onPropagation</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>from</name></decl></parameter>)</parameter_list> <block>{
                <comment type="line">// TODO Auto-generated method stub</comment>

            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ConflictTimer</name></type> <name>memoryTimer</name> <init>= <expr><operator>new</operator> <call><name>MemoryBasedConflictTimer</name><argument_list>(<argument><expr><name>this</name></expr></argument>,
            <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>LearnedConstraintsDeletionStrategy</name></type> <name>activity_based_low_memory</name> <init>= <expr><operator>new</operator> <call><name>ActivityLCDS</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>memoryTimer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ConflictTimer</name></type> <name>lbdTimer</name> <init>= <expr><operator>new</operator> <call><name>LBDConflictTimer</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>LearnedConstraintsDeletionStrategy</name></type> <name>lbd_based</name> <init>= <expr><operator>new</operator> <call><name><name>Glucose2LCDS</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>lbdTimer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.3.6
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>LearnedConstraintsDeletionStrategy</name></type> <name>age_based</name> <init>= <expr><operator>new</operator> <call><name>AgeLCDS</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>lbdTimer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.3.6
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>LearnedConstraintsDeletionStrategy</name></type> <name>activity_based</name> <init>= <expr><operator>new</operator> <call><name>ActivityLCDS</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>lbdTimer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.3.6
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <type><specifier>final</specifier> <name>LearnedConstraintsDeletionStrategy</name></type> <name>size_based</name> <init>= <expr><operator>new</operator> <call><name>SizeLCDS</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>lbdTimer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>LearnedConstraintsDeletionStrategy</name></type> <name>learnedConstraintsDeletionStrategy</name> <init>= <expr><name><name>this</name><operator>.</operator><name>lbd_based</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see
     * org.sat4j.minisat.core.ICDCL#setLearnedConstraintsDeletionStrategy(org
     * .sat4j.minisat.core.Solver.LearnedConstraintsDeletionStrategy)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLearnedConstraintsDeletionStrategy</name><parameter_list>(
            <parameter><decl><type><name>LearnedConstraintsDeletionStrategy</name></type> <name>lcds</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>lcds</name><operator>.</operator><name>getTimer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name>
                    <operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>getTimer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <name>lcds</name></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>lastConflictMeansUnsat</name></decl>;</decl_stmt>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isSatisfiable</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>assumps</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>global</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>Lbool</name></type> <name>status</name> <init>= <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>alreadylaunched</name> <init>= <expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>howmany</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nVars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>mseen</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <name>howmany</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>mseen</name></name> <operator>=</operator> <operator>new</operator> <name><name>boolean</name><index>[<expr><name>howmany</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>ensure</name></name><argument_list>(<argument><expr><name>howmany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>ensure</name></name><argument_list>(<argument><expr><name>howmany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedLiterals</name><operator>.</operator><name>ensure</name></name><argument_list>(<argument><expr><name>howmany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>decisions</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>implied</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>model</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt> <comment type="line">// forget about previous model</comment>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>userbooleanmodel</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>prime</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <comment type="line">// To make sure that new literals in the assumptions appear in the</comment>
        <comment type="line">// solver data structures</comment>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>localAssumps</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><call><name><name>assumps</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>IteratorInt</name></type> <name>iterator</name> <init>= <expr><call><name><name>assumps</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>assump</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>localAssumps</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>getFromPool</name></name><argument_list>(<argument><expr><name>assump</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><operator>!</operator><name>alreadylaunched</name> <operator>||</operator> <operator>!</operator><name><name>this</name><operator>.</operator><name>keepHot</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>learnedLiteralsLimit</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Fix for Bug SAT37</comment>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="line">// Apply undos on unit literals because they are getting propagated</comment>
        <comment type="line">// again now that qhead is 0.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>learnedLiteralsLimit</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Undoable</name></argument>&gt;</argument_list></name></type> <name>undos</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>undos</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>undos</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>undos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>size</name><operator>--</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><call><name><name>undos</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>undo</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>undos</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <comment type="line">// push previously learned literals</comment>
        <for>for <control>(<init><decl><type><name>IteratorInt</name></type> <name>iterator</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>learnedLiterals</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name>
                <operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <expr_stmt><expr><call><name>enqueue</name><argument_list>(<argument><expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// propagate constraints</comment>
        <decl_stmt><decl><type><name>Constr</name></type> <name>confl</name> <init>= <expr><call><name>propagate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>confl</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>analyzeAtRootLevel</name><argument_list>(<argument><expr><name>confl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>conflictFound</name></name><argument_list>(<argument><expr><name>confl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>end</name></name><argument_list>(<argument><expr><name><name>Lbool</name><operator>.</operator><name>FALSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cancelLearntLiterals</name><argument_list>(<argument><expr><name>learnedLiteralsLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>

        <comment type="line">// push incremental assumptions</comment>
        <for>for <control>(<init><decl><type><name>IteratorInt</name></type> <name>iterator</name> <init>= <expr><call><name><name>localAssumps</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name>
                <operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>assume</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <operator>(</operator><name>confl</name> <operator>=</operator> <call><name>propagate</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>confl</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>conflictFound</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name></name> <operator>=</operator> <call><name>analyzeFinalConflictInTermsOfAssumptions</name><argument_list>(
                            <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>assumps</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name>toDimacs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>conflictFound</name></name><argument_list>(<argument><expr><name>confl</name></expr></argument>, <argument><expr><call><name>decisionLevel</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name></name> <operator>=</operator> <call><name>analyzeFinalConflictInTermsOfAssumptions</name><argument_list>(
                            <argument><expr><name>confl</name></expr></argument>, <argument><expr><name>assumps</name></expr></argument>, <argument><expr><name><name>ILits</name><operator>.</operator><name>UNDEFINED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>end</name></name><argument_list>(<argument><expr><name><name>Lbool</name><operator>.</operator><name>FALSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cancelLearntLiterals</name><argument_list>(<argument><expr><name>learnedLiteralsLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>rootLevel</name></name> <operator>=</operator> <call><name>decisionLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// moved initialization here if new literals are added in the</comment>
        <comment type="line">// assumptions.</comment>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learner</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><operator>!</operator><name>alreadylaunched</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>=</operator> <operator>new</operator> <call><name>ConflictTimerContainer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>restarter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name>
                    <operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>getTimer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>boolean</name></type> <name>firstTimeGlobal</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>!</operator><name>global</name> <operator>||</operator> <name><name>this</name><operator>.</operator><name>timer</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>firstTimeGlobal</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>TimerTask</name></type> <name>stopMe</name> <init>= <expr><operator>new</operator> <class><super><name>TimerTask</name></super><argument_list>()</argument_list> <block>{
                    <function><annotation>@<name>Override</name></annotation>
                    <specifier>public</specifier> <type><name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
                        <expr_stmt><expr><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <synchronized>synchronized <init>(<expr><name><name>Solver</name><operator>.</operator><name>this</name></name></expr>)</init> <block>{
                            <if>if <condition>(<expr><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>timer</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>timer</name><operator>.</operator><name>cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>Solver</name><operator>.</operator><name>this</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></synchronized>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <operator>new</operator> <call><name>Timer</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>timer</name><operator>.</operator><name>schedule</name></name><argument_list>(<argument><expr><name>stopMe</name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><operator>!</operator><name>global</name> <operator>||</operator> <operator>!</operator><name>alreadylaunched</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>firstTimeGlobal</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>ConflictTimer</name></type> <name>conflictTimeout</name> <init>= <expr><operator>new</operator> <class><super><name>ConflictTimerAdapter</name></super><argument_list>(<argument><expr><name>this</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>this</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list> <block>{
                    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

                    <function><annotation>@<name>Override</name></annotation>
                    <specifier>public</specifier> <type><name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
                        <expr_stmt><expr><call><name>getSolver</name><argument_list>()</argument_list></call><operator>.</operator><call><name>expireTimeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>conflictTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
        <if>if <condition>(<expr><operator>!</operator><name>global</name> <operator>||</operator> <name>firstTimeGlobal</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>restarter</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>params</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>.</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timebegin</name></name> <operator>=</operator> <call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>needToReduceDB</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <comment type="line">// this is used to allow the solver to be incomplete,</comment>
        <comment type="line">// when using a heuristics limited to a subset of variables</comment>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>lastConflictMeansUnsat</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <comment type="line">// Solve</comment>
        <while>while <condition>(<expr><name>status</name> <operator>==</operator> <name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name> <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>undertimeout</name></name>
                <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>lastConflictMeansUnsat</name></name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>before</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>unitClauseProvider</name><operator>.</operator><name>provideUnitClauses</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>incImportedUnits</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>search</name><argument_list>(<argument><expr><name>assumps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> <operator>==</operator> <name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>restarter</name><operator>.</operator><name>onRestart</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>restarting</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>

        <expr_stmt><expr><call><name>cancelUntil</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cancelLearntLiterals</name><argument_list>(<argument><expr><name>learnedLiteralsLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><name>global</name> <operator>&amp;&amp;</operator> <name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr>)</condition><then> <block>{
            <synchronized>synchronized <init>(<expr><name>this</name></expr>)</init> <block>{
                <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>timer</name><operator>.</operator><name>cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                }</block></then></if>
            }</block></synchronized>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>slistener</name><operator>.</operator><name>end</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>.</operator><name>undertimeout</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>message</name> <init>= <expr><literal type="string">" Timeout ("</literal> <operator>+</operator> <name><name>this</name><operator>.</operator><name>timeout</name></name>
                    <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr> ?</condition><then> <expr><literal type="string">"ms"</literal></expr> </then><else>: <expr><literal type="string">" conflicts"</literal></expr></else></ternary><operator>)</operator>
                    <operator>+</operator> <literal type="string">") exceeded"</literal></expr></init></decl>;</decl_stmt>
            <throw>throw <expr><operator>new</operator> <call><name>TimeoutException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>status</name> <operator>==</operator> <name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>this</name><operator>.</operator><name>lastConflictMeansUnsat</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>TimeoutException</name><argument_list>(<argument><expr><literal type="string">"Cannot decide the satisfiability"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <comment type="line">// When using a search enumerator (to compute all models)</comment>
        <comment type="line">// the final answer is FALSE, however we are aware of at least one model</comment>
        <comment type="line">// (the last one)</comment>
        <return>return <expr><name>model</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>printInfos</name><parameter_list>(<parameter><decl><type><name>PrintWriter</name></type> <name>out</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>printInfos</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>printInfos</name><parameter_list>(<parameter><decl><type><name>PrintWriter</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>print</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"constraints type "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" =&gt; "</literal> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>print</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>print</name></name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">" constraints processed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>printLearntClausesInfos</name><parameter_list>(<parameter><decl><type><name>PrintWriter</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name></type> <name>learntTypes</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>learnts</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>type</name> <init>= <expr><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getClass</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Counter</name></type> <name>count</name> <init>= <expr><call><name><name>learntTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>learntTypes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>Counter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Counter</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>learntTypes</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <literal type="string">"learnt constraints type "</literal> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call>
                    <operator>+</operator> <literal type="string">"\t: "</literal> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><specifier>public</specifier> <type><name>SolverStats</name></type> <name>getStats</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>stats</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * 
     * @param myStats
     * @since 2.2
     */</comment>
    <function><specifier>protected</specifier> <type><name>void</name></type> <name>initStats</name><parameter_list>(<parameter><decl><type><name>SolverStats</name></type> <name>myStats</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>myStats</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#getOrder()
     */</comment>
    <function><specifier>public</specifier> <type><name>IOrder</name></type> <name>getOrder</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>order</name></name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.minisat.core.ICDCL#setOrder(org.sat4j.minisat.core.IOrder)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setOrder</name><parameter_list>(<parameter><decl><type><name>IOrder</name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>order</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>setLits</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>voc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>ILits</name></type> <name>getVocabulary</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>voc</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>timer</name><operator>.</operator><name>cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>trailLim</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>iterator</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iterator</name>
                <operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{
            <expr_stmt><expr><call><name><name>iterator</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>remove</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clearLearntClauses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>resetPool</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>undertimeout</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>int</name></type> <name>nVars</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nVars</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name><name>this</name><operator>.</operator><name>declaredMaxVarId</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param constr
     *            a constraint implementing the Constr interface.
     * @return a reference to the constraint for external use.
     */</comment>
    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addConstr</name><parameter_list>(<parameter><decl><type><name>Constr</name></type> <name>constr</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>constr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Counter</name></type> <name>count</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name>
                    <operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"ignored satisfied constraints"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"ignored satisfied constraints"</literal></expr></argument>,
                        <argument><expr><operator>new</operator> <call><name>Counter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>type</name> <init>= <expr><call><name><name>constr</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Counter</name></type> <name>count</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrTypes</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>Counter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>count</name><operator>.</operator><name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>constr</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>DataStructureFactory</name></type> <name>getDSFactory</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>dsfactory</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IVecInt</name></type> <name>getOutLearnt</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>moutLearnt</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * returns the ith constraint in the solver.
     * 
     * @param i
     *            the constraint number (begins at 0)
     * @return the ith constraint
     */</comment>
    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>getIthConstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see org.sat4j.specs.ISolver#printStat(java.io.PrintStream,
     * java.lang.String)
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>printStat</name><parameter_list>(<parameter><decl><type><name>PrintStream</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>printStat</name><argument_list>(<argument><expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>printStat</name><parameter_list>(<parameter><decl><type><name>PrintWriter</name></type> <name>out</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>printStat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>printStat</name><parameter_list>(<parameter><decl><type><name>PrintWriter</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>printStat</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>cputime</name> <init>= <expr><operator>(</operator><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>this</name><operator>.</operator><name>timebegin</name></name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <literal type="string">"speed (assignments/second)\t: "</literal> <comment type="line">//$NON-NLS-1$</comment>
                <operator>+</operator> <call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>getPropagations</name></name><argument_list>()</argument_list></call> <operator>/</operator> <name>cputime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>printStat</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printLearntClausesInfos</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>stb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Object</name><index>[]</index></name></type> <name>objs</name> <init>= <expr><block>{ <expr><name><name>this</name><operator>.</operator><name>dsfactory</name></name></expr>, <expr><name><name>this</name><operator>.</operator><name>learner</name></name></expr>, <expr><name><name>this</name><operator>.</operator><name>params</name></name></expr>, <expr><name><name>this</name><operator>.</operator><name>order</name></name></expr>,
                <expr><name><name>this</name><operator>.</operator><name>simplifier</name></name></expr>, <expr><name><name>this</name><operator>.</operator><name>restarter</name></name></expr>,
                <expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"--- Begin Solver configuration ---"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
        <for>for <control>(<init><decl><type><name>Object</name></type> <name>o</name> <range>: <expr><name>objs</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>o</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
        }</block></for>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"timeout="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>timeout</name></name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"s\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" conflicts\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"DB Simplification allowed="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>isDBSimplificationAllowed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>isSolverKeptHot</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(
                    <argument><expr><literal type="string">"Heuristics kept accross calls (keep the solver \"hot\")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Listener: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>slistener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"--- End Solver configuration ---"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
        <return>return <expr><call><name><name>stb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */</comment>
    <function><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <type><name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>toString</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return> <comment type="line">//$NON-NLS-1$</comment>
    }</block></function>

    <function><specifier>public</specifier> <type><name>int</name></type> <name>getTimeout</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call>(<name>int</name>) <argument_list>(<argument><expr><ternary><condition><expr><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr> ?</condition><then> <expr><name><name>this</name><operator>.</operator><name>timeout</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>
                </then><else>: <expr><name><name>this</name><operator>.</operator><name>timeout</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>long</name></type> <name>getTimeoutMs</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>.</operator><name>timeBasedTimeout</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(
                    <argument><expr><literal type="string">"The timeout is given in number of conflicts!"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name><name>this</name><operator>.</operator><name>timeout</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setExpectedNumberOfClauses</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>constrs</name><operator>.</operator><name>ensure</name></name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Number</name></argument>&gt;</argument_list></name></type> <name>getStat</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>stats</name><operator>.</operator><name>toMap</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>findModel</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name>isSatisfiable</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>model</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="line">// DLB findbugs ok</comment>
        <comment type="line">// A zero length array would mean that the formula is a tautology.</comment>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>findModel</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>assumps</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name>isSatisfiable</name><argument_list>(<argument><expr><name>assumps</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>model</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="line">// DLB findbugs ok</comment>
        <comment type="line">// A zero length array would mean that the formula is a tautology.</comment>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isDBSimplificationAllowed</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>isDBSimplificationAllowed</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setDBSimplificationAllowed</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isDBSimplificationAllowed</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>nextFreeVarId</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>reserve</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nextFreeVarId</name></name><argument_list>(<argument><expr><name>reserve</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addBlockingClause</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>literals</name></decl></parameter>)</parameter_list>
            <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>addClause</name><argument_list>(<argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>discardCurrentModel</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ContradictionException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>blockingClause</name> <init>= <expr><call><name>createBlockingClauseForCurrentModel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>blockingClause</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>ContradictionException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>addBlockingClause</name><argument_list>(<argument><expr><name>blockingClause</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IVecInt</name></type> <name>createBlockingClauseForCurrentModel</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>clause</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><call><name><name>decisions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>realNumberOfVariables</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name>nVars</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// we rely on the model projection in that case</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>p</name> <range>: <expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></range></decl></init>)</control> <block>{
                <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then> <else>else <block>{
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>decisions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><operator>-</operator><call><name><name>decisions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>

        <return>return <expr><name>clause</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.1
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>unset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{
        <comment type="line">// the literal might already have been</comment>
        <comment type="line">// removed from the trail.</comment>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isUnassigned</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>current</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>current</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return;</return>
            }</block></then></if>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>trailLim</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>current</name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>undoOne</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name><name>trailLim</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>trailLim</name><operator>.</operator><name>last</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>trailLim</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>qhead</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.6
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>getPropagationLevel</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLogPrefix</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>String</name></type> <name>getLogPrefix</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>prefix</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.2
     */</comment>
    <function><specifier>public</specifier> <type><name>IVecInt</name></type> <name>unsatExplanation</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="null">null</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>copy</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(
                <argument><expr><call><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>unsatExplanationInTermsOfAssumptions</name><operator>.</operator><name>copyTo</name></name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>copy</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.1
     */</comment>
    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>modelWithInternalVariables</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>model</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(
                    <argument><expr><literal type="string">"Call the solve method first!!!"</literal></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">//$NON-NLS-1$</comment>
        }</block></then></if>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>nmodel</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>nVars</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>realNumberOfVariables</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>nmodel</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name><name>this</name><operator>.</operator><name>model</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>model</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nmodel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nmodel</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>nmodel</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name><name>this</name><operator>.</operator><name>fullmodel</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>fullmodel</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nmodel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nmodel</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <return>return <expr><name>nmodel</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.1
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>realNumberOfVariables</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>nVars</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>stop</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>expireTimeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><specifier>protected</specifier> <type><name>Constr</name></type> <name>sharedConflict</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>backtrack</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>clause</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><name><name>reason</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>d</name> <range>: <expr><name>reason</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createUnregisteredClause</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>learn</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>Lbool</name></type> <name>truthValue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>literal</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><name>literal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isFalsified</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>Lbool</name><operator>.</operator><name>FALSE</name></name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>this</name><operator>.</operator><name>voc</name><operator>.</operator><name>isSatisfied</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>Lbool</name><operator>.</operator><name>TRUE</name></name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name><name>Lbool</name><operator>.</operator><name>UNDEFINED</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>currentDecisionLevel</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>decisionLevel</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>getLiteralsPropagatedAt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>decisionLevel</name></decl></parameter>)</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"Not implemented yet!"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>suggestNextLiteralToBranchOn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><literal type="string">"Not implemented yet!"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>isNeedToReduceDB</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>needToReduceDB</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setNeedToReduceDB</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>needToReduceDB</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>needToReduceDB</name></name> <operator>=</operator> <name>needToReduceDB</name></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLogger</name><parameter_list>(<parameter><decl><type><name>ILogAble</name></type> <name>out</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>public</specifier> <type><name>ILogAble</name></type> <name>getLogger</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>out</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name><name>double</name><index>[]</index></name></type> <name>getVariableHeuristics</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>this</name><operator>.</operator><name>order</name><operator>.</operator><name>getVariableHeuristics</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name><name>IVec</name><argument_list type="generic">&lt;<argument><name>Constr</name></argument>&gt;</argument_list></name></type> <name>getLearnedConstraints</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>learnts</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLearnedConstraintsDeletionStrategy</name><parameter_list>(<parameter><decl><type><name>ConflictTimer</name></type> <name>timer</name></decl></parameter>,
            <parameter><decl><type><name>LearnedConstraintsEvaluationType</name></type> <name>evaluation</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>conflictCount</name>
                    <operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>getTimer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <switch>switch <condition>(<expr><name>evaluation</name></expr>)</condition> <block>{
        <case>case <expr><name>ACTIVITY</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name>ActivityLCDS</name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LBD</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>GlucoseLCDS</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LBD2</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>Glucose2LCDS</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @since 2.3.2
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setLearnedConstraintsDeletionStrategy</name><parameter_list>(
            <parameter><decl><type><name>LearnedConstraintsEvaluationType</name></type> <name>evaluation</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>ConflictTimer</name></type> <name>aTimer</name> <init>= <expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name>
                <operator>.</operator><name>getTimer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>evaluation</name></expr>)</condition> <block>{
        <case>case <expr><name>ACTIVITY</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name>ActivityLCDS</name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>aTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LBD</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>GlucoseLCDS</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>aTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LBD2</name></expr>:</case>
            <expr_stmt><expr><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name></name> <operator>=</operator> <operator>new</operator> <call><name><name>Glucose2LCDS</name><argument_list type="generic">&lt;<argument><name>D</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                    <argument><expr><name>aTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
        <if>if <condition>(<expr><name><name>this</name><operator>.</operator><name>conflictCount</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>learnedConstraintsDeletionStrategy</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isSolverKeptHot</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name><operator>.</operator><name>keepHot</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setKeepSolverHot</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>keepHot</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>keepHot</name></name> <operator>=</operator> <name>keepHot</name></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>dimacsLevel</name> <init>= <expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
        <function><specifier>public</specifier> <type><name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>Integer</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>Integer</name></type> <name>i2</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><call><name><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <function><specifier>private</specifier> <specifier>final</specifier> <type><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>trailComparator</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{

            <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>trailLevel</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <block>{
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>trail</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <expr_stmt><expr><call><name><name>trailLevel</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name>var</name><argument_list>(<argument><expr><call><name><name>trail</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block>

            <function><specifier>public</specifier> <type><name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>Integer</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>Integer</name></type> <name>i2</name></decl></parameter>)</parameter_list> <block>{
                <decl_stmt><decl><type><name>Integer</name></type> <name>trail1</name> <init>= <expr><call><name><name>trailLevel</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Integer</name></type> <name>trail2</name> <init>= <expr><call><name><name>trailLevel</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>trail1</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name>trail2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
                }</block></then></if>
                <return>return <expr><name>trail2</name> <operator>-</operator> <name>trail1</name></expr>;</return>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addClauseOnTheFly</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>literals</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>lliterals</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Integer</name></type> <name>d</name> <range>: <expr><name>literals</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>lliterals</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>lliterals</name></expr></argument>, <argument><expr><call><name>trailComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>clause</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><name><name>literals</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>d</name> <range>: <expr><name>lliterals</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>dsfactory</name><operator>.</operator><name>createUnregisteredClause</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>sharedConflict</name><operator>.</operator><name>register</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addConstr</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>ISolver</name></type> <name>getSolvingEngine</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>this</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * 
     * @param literals
     */</comment>
    <function><specifier>public</specifier> <type><name>IConstr</name></type> <name>addAtMostOnTheFly</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>literals</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>degree</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>clause</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><name><name>literals</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>d</name> <range>: <expr><name>literals</name></expr></range></decl></init>)</control> <block>{
            <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name><name>LiteralsUtils</name><operator>.</operator><name>toInternal</name></name><argument_list>(<argument><expr><operator>-</operator><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><name>IVecInt</name></type> <name>copy</name> <init>= <expr><operator>new</operator> <call><name>VecInt</name><argument_list>(<argument><expr><call><name><name>clause</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>clause</name><operator>.</operator><name>copyTo</name></name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name> <operator>=</operator> <call><name><name>this</name><operator>.</operator><name>dsfactory</name>
                <operator>.</operator><name>createUnregisteredCardinalityConstraint</name></name><argument_list>(<argument><expr><name>copy</name></expr></argument>,
                        <argument><expr><name><name>literals</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>degree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>sharedConflict</name><operator>.</operator><name>register</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addConstr</name><argument_list>(<argument><expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>this</name><operator>.</operator><name>sharedConflict</name></name></expr>;</return>
    }</block></function>

    <function><specifier>protected</specifier> <type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>fromLastDecisionLevel</name><parameter_list>(<parameter><decl><type><name>IVecInt</name></type> <name>lits</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>subset</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>q</name></decl>, <decl><type ref="prev"/><name>level</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>lits</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name><name>lits</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>level</name> <operator>=</operator> <call><name><name>voc</name><operator>.</operator><name>getLevel</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>subset</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>subset</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
            }</block></then> <elseif>else <if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>subset</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif></if>
        }</block></for>
        <return>return <expr><name>subset</name></expr>;</return>
    }</block></function>

    <function><specifier>public</specifier> <type><name>void</name></type> <name>setUnitClauseProvider</name><parameter_list>(<parameter><decl><type><name>UnitClauseProvider</name></type> <name>ucp</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>unitClauseProvider</name></name> <operator>=</operator> <name>ucp</name></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
